/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.connectors.kafka.sink

import com.fasterxml.jackson.core.JsonParseException
import org.apache.kafka.common.config.ConfigException
import org.apache.kafka.connect.data.Schema
import org.apache.kafka.connect.header.Header
import org.apache.kafka.connect.sink.SinkRecord
import org.neo4j.caniuse.CanIUse.canIUse
import org.neo4j.caniuse.Cypher
import org.neo4j.connectors.kafka.data.DynamicTypes
import org.neo4j.connectors.kafka.data.cdcTxId
import org.neo4j.connectors.kafka.data.cdcTxSeq
import org.neo4j.connectors.kafka.data.fetchConstraintData
import org.neo4j.connectors.kafka.data.isCdcMessage
import org.neo4j.connectors.kafka.sink.strategy.CdcSchemaHandler
import org.neo4j.connectors.kafka.sink.strategy.CdcSourceIdHandler
import org.neo4j.connectors.kafka.sink.strategy.CudHandler
import org.neo4j.connectors.kafka.sink.strategy.CypherHandler
import org.neo4j.connectors.kafka.sink.strategy.NodePatternHandler
import org.neo4j.connectors.kafka.sink.strategy.RelationshipPatternHandler
import org.neo4j.connectors.kafka.sink.strategy.cdc.Cypher25CdcSchemaHandler
import org.neo4j.connectors.kafka.sink.strategy.cdc.Cypher25CdcSourceIdHandler
import org.neo4j.connectors.kafka.sink.strategy.pattern.NodePattern
import org.neo4j.connectors.kafka.sink.strategy.pattern.Pattern
import org.neo4j.connectors.kafka.sink.strategy.pattern.RelationshipPattern
import org.neo4j.connectors.kafka.utils.JSONUtils
import org.neo4j.driver.Query

data class SinkMessage(val record: SinkRecord) {
  val topic
    get(): String = record.topic()

  val keySchema
    get(): Schema? = record.keySchema()

  val key
    get(): Any? = record.key()

  val valueSchema
    get(): Schema? = record.valueSchema()

  val value
    get(): Any? = record.value()

  val headers
    get(): Iterable<Header> = record.headers()

  val isCdcMessage
    get(): Boolean = record.isCdcMessage()

  val cdcTxInfo
    get(): Pair<Long, Int> =
        if (!isCdcMessage) throw IllegalArgumentException("not a message generated by cdc")
        else Pair(record.cdcTxId()!!, record.cdcTxSeq()!!)

  fun valueFromConnectValue(): Any? {
    return fromConnectValue(valueSchema, value)
  }

  fun keyFromConnectValue(): Any? {
    return fromConnectValue(keySchema, key)
  }

  fun headerFromConnectValue(): Map<String, Any?> {
    return headers.associate { it.key() to fromConnectValue(it.schema(), it.value()) }
  }

  private fun fromConnectValue(schema: Schema?, value: Any?): Any? {
    return schema?.let {
      DynamicTypes.fromConnectValue(it, value)?.let {
        // if incoming schema is a built-in BYTES or STRING, then we try a json parsing for backward
        // compatibility
        if (
            schema.name().isNullOrEmpty() &&
                (schema.type() == Schema.Type.STRING || schema.type() == Schema.Type.BYTES)
        ) {
          try {
            JSONUtils.readValue<Any?>(it)
          } catch (ex: JsonParseException) {
            it
          }
        } else it
      }
    } ?: value
  }

  override fun toString(): String {
    return "SinkMessage{topic=${record.topic()},partition=${record.kafkaPartition()},offset=${record.kafkaOffset()},timestamp=${record.timestamp()},timestampType=${record.timestampType()}}"
  }
}

enum class SinkStrategy(val description: String) {
  CDC_SCHEMA("cdc-schema"),
  CDC_SOURCE_ID("cdc-source-id"),
  CYPHER("cypher"),
  CUD("cud"),
  NODE_PATTERN("node-pattern"),
  RELATIONSHIP_PATTERN("relationship-pattern"),
}

data class ChangeQuery(
    val txId: Long?,
    val seq: Int?,
    val messages: Iterable<SinkMessage>,
    val query: Query,
)

interface SinkStrategyHandler {

  fun strategy(): SinkStrategy

  /**
   * Process incoming sink messages by converting them into Cypher queries, grouped as transactional
   * boundaries. Each `Iterable<ChangeQuery>` will be executed as a transaction.
   *
   * @param messages Incoming sink messages
   * @return Iterable of change queries split into transactional boundaries
   */
  fun handle(messages: Iterable<SinkMessage>): Iterable<Iterable<ChangeQuery>>

  companion object {

    fun createFrom(config: SinkConfiguration): Map<String, SinkStrategyHandler> {
      return config.topicNames.associateWith { topic -> createForTopic(topic, config) }
    }

    private fun createForTopic(topic: String, config: SinkConfiguration): SinkStrategyHandler {
      var handler: SinkStrategyHandler? = null
      val originals = config.originalsStrings()

      val query = originals[SinkConfiguration.CYPHER_TOPIC_PREFIX + topic]
      if (query != null) {
        handler =
            CypherHandler(
                topic,
                query,
                config.renderer,
                config.batchSize,
                bindTimestampAs = config.cypherBindTimestampAs,
                bindHeaderAs = config.cypherBindHeaderAs,
                bindKeyAs = config.cypherBindKeyAs,
                bindValueAs = config.cypherBindValueAs,
                bindValueAsEvent = config.cypherBindValueAsEvent,
            )
      }

      val pattern = originals[SinkConfiguration.PATTERN_TOPIC_PREFIX + topic]
      if (pattern != null) {
        if (handler != null) {
          throw ConfigException("Topic '${topic}' has multiple strategies defined")
        }

        val patternHandler =
            when (val parsedPattern = Pattern.parse(pattern)) {
              is NodePattern ->
                  NodePatternHandler(
                      topic,
                      parsedPattern,
                      config.getString(SinkConfiguration.PATTERN_MERGE_NODE_PROPERTIES).toBoolean(),
                      config.renderer,
                      config.batchSize,
                      bindTimestampAs = config.patternBindTimestampAs,
                      bindHeaderAs = config.patternBindHeaderAs,
                      bindKeyAs = config.patternBindKeyAs,
                      bindValueAs = config.patternBindValueAs,
                  )
              is RelationshipPattern ->
                  RelationshipPatternHandler(
                      topic,
                      parsedPattern,
                      config.getString(SinkConfiguration.PATTERN_MERGE_NODE_PROPERTIES).toBoolean(),
                      config
                          .getString(SinkConfiguration.PATTERN_MERGE_RELATIONSHIP_PROPERTIES)
                          .toBoolean(),
                      config.renderer,
                      config.batchSize,
                      bindTimestampAs = config.patternBindTimestampAs,
                      bindHeaderAs = config.patternBindHeaderAs,
                      bindKeyAs = config.patternBindKeyAs,
                      bindValueAs = config.patternBindValueAs,
                  )
              else ->
                  throw IllegalArgumentException(
                      "Invalid pattern provided for PatternHandler: ${parsedPattern.javaClass.name}"
                  )
            }

        patternHandler.validate(fetchConstraintData(config.driver, config.sessionConfig()))

        handler = patternHandler
      }

      val cdcMaxBatchedStatements = config.getInt(SinkConfiguration.CDC_MAX_BATCHED_QUERIES)
      val cdcSourceIdTopics = config.getList(SinkConfiguration.CDC_SOURCE_ID_TOPICS)
      if (cdcSourceIdTopics.contains(topic)) {
        if (handler != null) {
          throw ConfigException("Topic '${topic}' has multiple strategies defined")
        }

        val labelName = config.getString(SinkConfiguration.CDC_SOURCE_ID_LABEL_NAME)
        val propertyName = config.getString(SinkConfiguration.CDC_SOURCE_ID_PROPERTY_NAME)

        handler =
            if (
                canIUse(Cypher.dynamicLabelsAndTypesCanLeverageIndicesOnPropertyValues())
                    .withNeo4j(config.neo4j)
            )
                Cypher25CdcSourceIdHandler(
                    topic,
                    cdcMaxBatchedStatements,
                    config.batchSize,
                    Cypher25Renderer(config.neo4j),
                    labelName,
                    propertyName,
                )
            else CdcSourceIdHandler(topic, config.renderer, labelName, propertyName)
      }

      val cdcSchemaTopics = config.getList(SinkConfiguration.CDC_SCHEMA_TOPICS)
      if (cdcSchemaTopics.contains(topic)) {
        if (handler != null) {
          throw ConfigException("Topic '${topic}' has multiple strategies defined")
        }

        handler =
            if (
                canIUse(Cypher.dynamicLabelsAndTypesCanLeverageIndicesOnPropertyValues())
                    .withNeo4j(config.neo4j)
            )
                Cypher25CdcSchemaHandler(
                    topic,
                    cdcMaxBatchedStatements,
                    config.batchSize,
                    Cypher25Renderer(config.neo4j),
                )
            else CdcSchemaHandler(topic, config.renderer)
      }

      val cudTopics = config.getList(SinkConfiguration.CUD_TOPICS)
      if (cudTopics.contains(topic)) {
        if (handler != null) {
          throw ConfigException("Topic '${topic}' has multiple strategies defined")
        }

        handler = CudHandler(topic, config.renderer, config.batchSize)
      }

      return handler ?: throw ConfigException("Topic '$topic' is not assigned a sink strategy")
    }

    fun configuredStrategies(config: SinkConfiguration): Set<String> {
      return config.topicNames
          .map { topic -> topicStrategy(topic, config) }
          .map { it.description }
          .toSet()
    }

    private fun topicStrategy(topic: String, config: SinkConfiguration): SinkStrategy {
      val originals = config.originalsStrings()

      val query = originals[SinkConfiguration.CYPHER_TOPIC_PREFIX + topic]
      if (query != null) {
        return SinkStrategy.CYPHER
      }

      val pattern = originals[SinkConfiguration.PATTERN_TOPIC_PREFIX + topic]
      if (pattern != null) {
        return when (val parsedPattern = Pattern.parse(pattern)) {
          is NodePattern -> SinkStrategy.NODE_PATTERN
          is RelationshipPattern -> SinkStrategy.RELATIONSHIP_PATTERN
          else ->
              throw IllegalArgumentException(
                  "Invalid pattern provided for PatternHandler: ${parsedPattern.javaClass.name}"
              )
        }
      }

      val cdcSourceIdTopics = config.getList(SinkConfiguration.CDC_SOURCE_ID_TOPICS)
      if (cdcSourceIdTopics.contains(topic)) {
        return SinkStrategy.CDC_SOURCE_ID
      }

      val cdcSchemaTopics = config.getList(SinkConfiguration.CDC_SCHEMA_TOPICS)
      if (cdcSchemaTopics.contains(topic)) {
        return SinkStrategy.CDC_SCHEMA
      }

      val cudTopics = config.getList(SinkConfiguration.CUD_TOPICS)
      if (cudTopics.contains(topic)) {
        return SinkStrategy.CUD
      }

      throw ConfigException("Topic $topic is not assigned a sink strategy")
    }
  }
}
